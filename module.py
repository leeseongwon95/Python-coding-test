# 파이썬 인터프리터를 종료한 후에 다시 들어가면 만들었던 정의들이 사라짐 (함수나 변수들)

# 그래서 좀 긴 프로그램을 쓰고자 한다면, 대신 인터프리터 입력을 편집기를 사용해서 준비한 후에 그 파일을 입력으로 사용해서 실행하는 것이 좋음

# 이것을 '스크립트' 를 만든다고 함 프로그램이 길어짐에 따라, 유지를 쉽게 하려고 여러 개의 파일로 나누고 싶을 수 있다. 여러 프로그램에서 썼던 편리함 함수를 각 프로그램에 정의를 복사하지 않고도 사용하고 싶을 수 있음

# 이것 을 지원하기 위해 파이썬은 정의들을 파일에 넣고 스크립트나 인터프리터의 대화형 모드에서 사용 할 수 있는 방법을 제공 함. 그런 파일을 모듈이라고 부름 

# 모듈로부터 정의들이 다른 모듈이나 메인모듈로 임포트 될 수 있음 (메인 모듈은 최상위 수준에서 실행되는 스크립트나 계산기 모드에서 액세스 하는 변수들의 컬렉션)

# 모듈은 파이썬 정의와 문장들을 담고 있는 파일임. 파일의 이름은 모듈 이름에 확장자 .py 를 붙임 모듈 내에서 , 모듈이름은 전역 변수 __name__ 으로 제공 됨 
# 예를 들면 좋아하는 편집기로 fibo.py 라는 이름의 파일을 현재 디렉터리에 만들고 내용을 채움 

# Fibonacci number module
def fib(n): # write Fibonacci series up to n
    a, b = 0 , 1
    while a < n:
        print(a, end=' ')
        a, b = b, a+b
    print()

def fib2(n): # return Fibonacci series up to n
    result = []
    a, b = 0, 1
    while a < n:
        result.appen(a)
        a, b = b, a+b
    return result

#  이제 파이썬 인터프리터에 들어가서 이 모듈을 다음과 같은 명령으로 임포트함

import fibo

fibo.fib(1000)
fibo.fib2(100)
fibo.__name__




# 모듈은 함수 정의 뿐만 아니라 실행 가능한 문장들도 포함할 수 있음. 이 문장들은 모듈을 초기화하는데 사용됨. 이것은 임포트 문에서 모듈 이름이 처음 등장할 때만 실행됨 (이것들은 파일이 스크립트로 실행될 때도 실행됨)

# 각 모듈은 자신만의 심볼 테이블을 갖고 있는데, 그 모듈에서 저으이된 함수들의 전역 심볼 테이블로 사용됨, 그래서 모듈의 저자는 사용자의 전역 변수와 우연히 충돌할 것을 걱정하지 않고 전역변수를 사용가능함
# 반면에 무얼 하는지 안다면, 모듈의 함수를 참조하는데 사용된 것과 같은 표기법으로 모듈의 전역변수들을 건드릴 수 있음

# 모듈은 다른 모듈들을 임포트 할 수 있음 모든 import 문들은 모듈의 처음에 놓는 것이 관례지만 반드시 그래야하는 것은 아님 . (그 점에 관한 한 스크립트도 만찬가지)
# 임포트 되는 모듈 이름은 임포트하는 모듈의 전역 심볼 테이블에 들어감

from fibo import fib, fib2 # 모듈에 들어 있는 이름들을 직접 임포트 하는 모듈으 ㅣ심볼 테이블로 임포트 하는 import 문의 변종
# 이것은 지역 심볼 테이블에 임포트 되는 모듈의 이름을 만들지 않음 (그래서 이 예에서는 fibo 가 정의되지 않음)


from fibo import * # 모듈이 정의하는 모든 이름을 임포트하는 변종도 있음

import fibo as fib # 모듈 이름 다음에 as 가 올 경우 as 다음의 이름을 임포트 한 모듈에 직접 연결

from fibo import fib as fibonacci # from 을 써서 비슷한 효과를 낼 때도 사용할 수 있음

# 모듈에 있는 코드는, 그것을 임포트 할 떄 처럼 실행됨 하지만 __name__ 은 "__main__" 로 설정 이 코드를 모듈의 끝에 붙여서
if __name__ == "__main__":
    import sys
    fib(int(sys.argy[1]))
# 파일을 임포트 할 수 있는 모듈뿐만 아니라 스크립트로도 사용할 수 있도록 만들 수 있음을 의미함
# 오직 모듈이 메인 파일로 실행될 때만 명령행을 파싱하는 코드가 실행 되기 때문

# 모듈 검색 경로 : spam 이라는 이름의 모듈이 임포트 될 때, 인터프리터는 먼저 그 이름의 내장 모듈을 찾음 발견되지 않으면, 변수 sys.path 로 주어지는 디렉터리 들에서 spam.py 라는 이름의 파일을 찾음
# sys.path 는 이 위치들로 초기화 됨

# - 입력 스크립트를 포함하는 디렉터리 (또는 파일이 지정되지 않았을 때는 현재 디렉터리)
# - PYTHONPATH (디렉터리 이름들의 목록, 셀 변수 PATH와 같은 문법)

# 초기화 후에 파이썬 프로그램은 sys.path 를 수정 할 수 있음 스크립트를 포함하는 디렉터리는 검색 경로의 처음에 표준 라이브러리 경로의 앞에 놓임 이것은 같은 이름일 경우 라이브러리 디렉터리에 있는 것 대신 스크립트를 포함하는 디렉터리의 것이 로드된다는 뜻
# 이 치환이 의도된 것이 아니라면 에러 자세한건 표준 모듈을 보면 됨

# 컴파일된 파이썬 파일은 모듈 로딩을 빠르게 하려고, 파이썬은 __pycache__ 디렉터리에 각 모듈의 커파일 된 버전을 
# 모듈 로딩을 빠르게 하려고, 파이썬은 __pycache__ 디렉터리에 각 모듈의 컴파일된 버전을 module.version.pyc 라는 이름으로 캐싱합니다. version 은 컴파일된 파일의 형식을 지정합니다; 일반적으로 파이썬의 버전 번호를 포함합니다. 예를 들어, CPython 배포 3.3 에서 spam.py 의 컴파일된 버전은 __pycache__/spam.cpython-33.pyc 로 캐싱 됩니다. 이 명명법은 서로 다른 파이썬 배포와 버전의 컴파일된 모듈들이 공존할 수 있도록 합니다.
# 파이썬은 소스의 수정 시간을 컴파일된 버전과 비교해서 시효가 지나 다시 컴파일해야 하는지 검사합니다. 이것은 완전히 자동화된 과정입니다. 또한, 컴파일된 모듈은 플랫폼 독립적이기 때문에, 같은 라이브러리를 서로 다른 아키텍처를 갖는 시스템들에서 공유할 수 있습니다.
# 파이썬은 두 가지 상황에서 캐시를 검사하지 않습니다. 첫째로, 명령행에서 직접 로드되는 모듈들은 항상 재컴파일하고 그 결과를 저장하지 않습니다. 둘째로, 소스 모듈이 없으면 캐시를 검사하지 않습니다. 소스 없는 (컴파일된 파일만 있는) 배포를 지원하려면, 컴파일된 모듈이 소스 디렉터리에 있어야 하고, 소스 모듈이 없어야 합니다.
# 전문가를 위한 몇 가지 팁
# 컴파일된 모듈의 크기를 줄이려면 파이썬 명령에 -O 나 -OO 스위치를 사용할 수 있습니다. -O 스위치는 assert 문을 제거하고, -OO 스위치는 assert 문과 __doc__ 문자열을 모두 제거합니다. 어떤 프로그램들은 이것들에 의존하기 때문에, 무엇을 하고 있는지 아는 경우만 이 옵션을 사용해야 합니다. 《최적화된》 모듈은 opt- 태그를 갖고, 보통 더 작습니다. 미래의 배포에서는 최적화의 효과가 변경될 수 있습니다.
# .py 파일에서 읽을 때보다 .pyc 파일에서 읽을 때 프로그램이 더 빨리 실행되지는 않습니다; .pyc 파일에서 더 빨라지는 것은 로드되는 속도뿐입니다.
# 모듈 compileall 은 디렉터리에 있는 모든 모듈의 .pyc 파일들을 만들 수 있습니다.
# 이 절차에 대한 더 자세한 정보, 결정들의 순서도를 포함합니다, 는 PEP 3147 에 나옵니다.

# 표준 모듈들 

# 파이썬은 표준 모듈들의 라이브러리가 함께 오는데, 별도의 문서 파이썬 라이브러리 래퍼런스 이후로는 라이브러리 레퍼런스에서 설명함 어떤 모듈들은 인터프리터에 내장됨 이것들은 언어으 ㅣ핵심적인 부분은 아니지만 그런데도 내장된 연산들에 대한 액세스를
# 제공하는데 효율이나 시스템 호출과 같은 운영 체제 기본 요소들에 대한 액세스를 제공하기 위함임 그런 모듈들의 집한은 설정 옵션인데 기반 플랫폼 의존적임

# 예를들면, winreg 모듈은 윈도우 시스템에서만 제공됨 특별한 모듈 하나는 주목을 받을 필요가 있음 sys 모든 파이썬 인터프리터에 내장됨 변수 sys.ps1 sys.ps2 는 기본과 보조 프롬프트로 사용되는 문자열을 정의함

import sys
sys.ps1
sys.ps2
sys.ps1 = 'C> '
# 이 두개의 변수들은 인터프리터가 대화형 모드일 때만 정의됨

# 변수 sys.path 는 인터프리터의 모듈 검색 경로를 결정하는 문자열들의 리스트임. 환경 변수 PYTHONPATH 에서 취한 기본 경로나, PYTHONPATH 가 설정되지 않는 경우 내장 기본값으로 초기화 됨 표쥰 리스트 연산을 사용해서 수정 가능

import sys
sys.path.append('/ufs/guido/lib/python')

# dir 함수 

import fibo, sys
dir(fibo)
dir(sys)
# 인자가 없으면 dir() 는 현재 정의 한 이름들을 나열함

a = [1, 2, 3, 4, 5]
import fibo
fib = fibo.fib
dir()

